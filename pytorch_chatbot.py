# -*- coding: utf-8 -*-
"""pneuma Chatbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yqcGw4_lOP250kRKfy0hS70zXxBEB_cN

### 1| SET THE ENVIRONMENT
"""

# Import packages
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import nltk
nltk.download('punkt')
from nltk.stem.porter import PorterStemmer
from datetime import datetime
import random
import string
import pandas as pd

# If there's a GPU available...
if torch.cuda.is_available():

    # Tell PyTorch to use the GPU
    device = torch.device("cuda")

    print('There are {} GPU(s) available.'.format(torch.cuda.device_count()))

    print('GPU name:', torch.cuda.get_device_name(0))

# If not, use the CPU
else:
    print('GPU not found, using the CPU instead.')
    device = torch.device("cpu")

"""### 2| CREATE TRAINING DATA"""

intents = {
    'intents': [
        {
            'tag': 'greeting',
            'patterns': [
                'Hi',
                'Hey',
                'Hello',
                'How are you',
                'Is anyone there?',
                'Good day'
            ],
            'responses': [
                'Hey, user',
                'Hello user, thanks for visiting',
                'Hi there, user, what can I do for you?',
                'Hi there, user, how can I help?',
                "Hello user, welcome to infinite possibilities. How can I help you today?"

            ]
        },
        {
            'tag': 'goodbye',
            'patterns': [
                'Bye',
                'See you later',
                'Goodbye'
            ],
            'responses': [
                'See you later, thanks for visiting',
                'Have a nice day',
                'Bye! Come back again soon'
            ]
        },
        {
            'tag': 'thanks',
            'patterns': [
                'Thanks',
                'Thank you',
                "That's helpful",
                'Thanks a lot!'
            ],
            'responses': [
                'Happy to help!',
                'Anytime!',
                "My pleasure"
            ]
        },

        {
            'tag': 'booking',
            'patterns': [
                'I would like to make a reservation',
                'Can I book a flight?',
                'Book me a flight',
                "I want to make a booking",
                "I want to purchase airline tickets",
                "Book me plane tickets"

            ],
            'responses': [
                'Sure, I only need to know a few details. Where are you headed?',
                "Lovely. Let's begin with the reservation. Where would you want to go?",
                  "Lovely. Let's begin with the reservation. Can you speak your current location?",
                    "Lovely. Let's begin with the reservation. What is your origin of the flight?",
                    'Lovley, should I book from your current location?',
             "And where would you want to fly from ?"

            ]
        },
        {
        'tag':'booking_info_origin',
         'patterns':['I want to book from my current location',
                     "I am going from Karachi",
                     "I am going from New York",
                     "I am based in Delhi , so i would be flying from there",
                     "Yes please use my current location"],
         'responses':['Almost getting there. And where are you headed?']

        },
        {
            'tag':'booking_info_desination',
            'patterns':[
                'Book me a flight to New York',
                "Can you please book me a plane ticket to Vermont",
                "I want to travel to Bangkok",
                'I want to go to Vermont',
                "I am flying to Chicago",
                "Brooklyn is where I would want to go "
                "Karachi",
                "New York"

            ],
         'responses':[
             'Amazing. When are you planning to leave?',

             ]
        },
        {
        'tag':'booking_dates_leave',
         'patterns':['I am leaving on 17th Januray',
                     "I would be needng tickets for 21st February",
                     "I want booking for 25th March",
                     "I am leaving on 21th April",
                     "I am leaving on 22th May",
                     "I am leaving on 6th June",
                     "I am leaving on 17th July",
                     "I am leaving on 1st August",
                     "I am leaving on 2nd September",
                     "I am leaving on 17th October",
                     "I am leaving on 12th November","I am leaving on 31st Decemeber"
                     ],
         "responses":['Lovley time to travel, And return when',
                      "Is it a return ticket?"]
        },
        {
        "tag":"booking_dates_return_yes",
         "patterns":["Yes, I will be coming back on April the 14th",
                     "Yes, I will be needing round way tickets for October 12th",
                     'I am coming back on 17th Januray',
                     "I would be needng tickets for 21st February",
                     "I want booking for 25th March",
                     "I am returning on 21th April",
                     "I am coming back on 22th May",
                     "I am returning 6th June",
                     "I am returning on 17th July",
                     "I am heading back on 1st August",
                     "I am coming back 2nd September",
                     "I am retunring 17th October",
                     "I am returning on 12th November","I am returning on 31st Decemeber"
                     ],
         "responses":["Perfect, hold on. I'll be back in a few seconds. So you would want to go from origin to destination on traveldate and return on backdate. Should I proceed? "]
        }
        ,
        {"tag":"booking_confirmation",
         "patterns":["Yes , the details are correct",
                     "Yes, please proceed with the booking"],
         "responses":["Alright, please wait. How many passengers are there?"]

        },

         {
            "tag":"booking_number_of_passengers_alone",
         "patterns":["I am travelling alone",
                     "It would only be me."],
         "responses":["Perfect.Should I use to current credit card for booking?"]

        },
        {
            "tag":"booking_number_of_passengers_more",
         "patterns":["I have two kids and two adults",
                     "Yes there are more people with me, three kids and three adults"],
         "responses":["Please state the ages of the childrens if any and Should I use to current credit card for booking?"]

        },

        {
            "tag":"booking_bank_details_yes",
         "patterns":["Yes use my current card",
                     "Yes you can use my current details",
                     "Ye charge my current card"],
         "responses":["Perfect. Fetching flights"]

        },

          {

        "tag":"booking_confirmation_final",
         "patterns":["Yes you got my preference right",
                     "Yes, I liked the flight option",
                     "Yes please proceed with the booking"],
         "responses":["Sure, can you please speak the phrase?"]

        },

        {
        "tag":"unknown",
        "patterns":['The sky is painted blue',
                     "Earth is moon"],
         "responses":["I am not sure If i understand you, can you speak again?"]

        },
        {
        "tag":"identification",
        "patterns":['Who are you?',"Why are you?","What can you do?","Are you real?"],
         "responses":["I am here to help you book tickets",
                     "I am at your service, you can call me Sara."]


        },{
          "tag":"cancellation",
        "patterns":["I would like to cancel my flight",
                    "I would like to cancel my booking",
                    "I need to cancel my flight",
                    "I need to cancel my booking",
                    "I would need you to cancel my booking"],
         "responses":["Sure, can you please say your reference number for me?"]


        }


    ]
}

import pandas as pd

# Creating an empty dictionary to store data of all tags
data_dict = {}

# Looping through each intent
for intent in intents['intents']:
    # Creating a dictionary to store patterns and responses of each tag
    tag_dict = {}
    tag_dict['Patterns'] = ', '.join(intent['patterns'])
    tag_dict['Responses'] = ', '.join(intent['responses'])

    # Adding tag dictionary to data dictionary
    data_dict[intent['tag']] = tag_dict

# Creating DataFrame from data dictionary
df = pd.DataFrame(data_dict)

# Transposing the DataFrame to make tags as row and patterns and responses as columns
df = df.transpose()

# Saving the DataFrame to an Excel file
# df.to_excel('intents.xlsx')

df.to_excel("intents.xlsx")

"""### 3| DATA PRE-PROCESSING"""

stemmer = PorterStemmer()
def tokenize(sentence):
    '''
    This function takes a sentence as an input,
    and returns a list of its tokens
    '''
    return nltk.word_tokenize(sentence)

def bag_of_words(tokenized_sentence, all_words):
    '''
    Function to represent a sentence into a vector of float numbers
    input: list of tokens in a sent and a list of all the words in the text
    output: vector equal to the vocab length for each sentence
    '''
    tokenized_sentence = [stemmer.stem(w.lower()) for w in tokenized_sentence]
    bag = np.zeros(len(all_words), dtype=np.float32)

    for idx, w in enumerate(all_words):
        if w in tokenized_sentence:
            bag[idx] = 1.0

    return bag

"""### 4| BUILDING THE MODEL"""

all_words = []
tags = []
xy = []

# Save all the keywords in different variables
for intent in intents['intents']:
    tag= intent['tag']
    tags.append(tag)
    for pattern in intent['patterns']:
        w = tokenize(pattern)
        all_words.extend(w)
        xy.append((w, tag))

# Create the vocabulary
ignore_words = ['?', '!', '.', ',']
all_words = [stemmer.stem(w.lower()) for w in all_words if w not in ignore_words]
all_words = sorted(set(all_words))
tags = sorted(set(tags))

all_words

tags

# Set the final training data
X_train = []
y_train = []
for (pattern_sentence, tag) in xy:
    bag = bag_of_words(pattern_sentence, all_words)
    X_train.append(bag)
    label = tags.index(tag)
    y_train.append(label)

X_train = np.array(X_train)
y_train = np.array(y_train)

class ChatDataset(Dataset):
    def __init__(self):
        self.n_samples = len(X_train)
        self.x_data = X_train
        self.y_data = y_train

    def __getitem__(self, index):
        return self.x_data[index], self.y_data[index]

    def __len__(self):
        return self.n_samples

class NeuralNet(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(NeuralNet, self).__init__()
        self.l1 = nn.Linear(input_size, hidden_size)
        self.l2 = nn.Linear(hidden_size, hidden_size)
        self.l3 = nn.Linear(hidden_size, num_classes)
        self.relu = nn.ReLU()

    def forward(self, x):
        out = self.l1(x)
        out = self.relu(out)
        out = self.l2(out)
        out = self.relu(out)
        out = self.l3(out)
        # no activation and no softmax
        return out

# Hyperparameters
batch_size=8
hidden_size=8
output_size=len(tags)
input_size = len(X_train[0])
learning_rate = 0.001
num_epochs = 1000

dataset = ChatDataset()
train_loader = DataLoader(dataset=dataset, batch_size=batch_size, shuffle=True, num_workers=2)

model = NeuralNet(input_size, hidden_size, output_size).to(device)

input_size,output_size,hidden_size

# Loss and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)

for epoch in range(num_epochs):
  for (words, labels) in train_loader:
    words = words.to(device)
    labels = labels.to(device)

    # Forward
    outputs = model(words)
    loss = criterion(outputs,labels)

    # Backward and optimizer
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

  if (epoch + 1) % 100 == 0:
    print(f'epoch {epoch + 1}/{num_epochs}, loss = {loss.item():.4f}')

print(f'final loss, loss = {loss.item():.4f}')

model_scripted = torch.jit.script(model) # Export to TorchScript
model_scripted.save('model_scripted.pt') # Save

"""### 5| IMPLEMENT CHATBOT"""

all_bookings = pd.DataFrame()

class Customer:

    rate = 99.00

    def __init__(self, name, dates, room, service):
        self.name = name
        self.dates = (datetime.strptime(dates[0], '%d/%m/%Y').date(), datetime.strptime(dates[1], '%d/%m/%Y').date())
        self.room = room
        self.service = service

    def ID(self):
        letters = string.ascii_uppercase
        digits = string.digits
        a = random.sample(letters, 3) + random.sample(digits, 4)
        self.id = ''.join(a)

    def nights(self):
        nights = (self.dates[1] - self.dates[0]).days
        return nights

    def final_price(self):
        price = self.rate * float(self.nights())
        return price

    def __str__(self):
        return f'''
        > Mr./Miss. {self.name[1]},
        >
        > We are delighted to confirm your booking with us for the {self.dates[0]} till the {self.dates[1]}.
        > A {self.room} with {self.service} for the final rate of £{self.rate} per night.
        > Total price: £{self.final_price()}
        > Your reference number is {self.id}.
        > Keep this number in case you want to modify or cancel your booking in the future.
        >
        > Best,
        > The Hollywood Hotel
        '''

del model

new_model = torch.jit.load('/content/model_scripted.pt')
model_dic = new_model.state_dict()
new_model = NeuralNet(input_size, hidden_size, output_size)
new_model.load_state_dict(model_dic)
new_model.eval()

# model_dic = model.state_dict()
# model = NeuralNet(input_size, hidden_size, output_size)
# model.load_state_dict(model_dic)
# model.eval()

bot_name = 'Bot '
print("Let's chat: type 'quit' to exit")

while True:
  sentence = input('You: ')
  if sentence == 'quit':
    break

  sentence = tokenize(sentence)
  X = bag_of_words(sentence, all_words)
  X = X.reshape(1, X.shape[0])
  X = torch.from_numpy(X)

  output = new_model(X)
  _,predicted = torch.max(output, dim=1)
  tag = tags[predicted.item()]

  probs = torch.softmax(output, dim=1)
  prob = probs[0][predicted.item()]

  if prob.item() > 0.75:
    for intent in intents['intents']:

      if tag == intent['tag']:

        if tag == 'greeting':
            print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag == 'goodbye':
            print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='thanks':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_dates_leave':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_info_origin':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_info_desination':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_dates_return_yes':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag =='booking_confirmation':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_number_of_passengers_alone':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_number_of_passengers_more':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='booking_bank_details_yes':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='identification':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='unknown':
          print(f"{bot_name}: {random.choice(intent['responses'])}")
        elif tag=='cancellation':
          print(f"{bot_name}: {random.choice(intent['responses'])}")

  else:
    print(f'{bot_name}: I do not understand...')

